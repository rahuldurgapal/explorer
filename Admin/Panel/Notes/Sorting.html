<title>Sorting</title>
<div class="notes_block">

    <h1 tabindex="-1" id="user-content-sorting" dir="auto"><a class="heading-link"
            href="https://github.com/mearjuntripathi/Data_Structure_Algorithm/tree/main/Sorting#sorting">Sorting<svg
                class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"></svg></a>
    </h1>
    <p dir="auto">The
        operation of sorting is the most common task performed by computers
        today. Sorting is used to arrange names and numbers in meaningful ways.</p>
    <h2 tabindex="-1" id="user-content-types-of-sorting" dir="auto"><a class="heading-link"
            href="https://github.com/mearjuntripathi/Data_Structure_Algorithm/tree/main/Sorting#types-of-sorting">Types
            of sorting<svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16"
                aria-hidden="true"></svg></a></h2>
    <p dir="auto">Sorting can be performed in many ways. Over a time several methods (or algorithms) are being developed
        to sort data(s).</p>
    <ul dir="auto">
        <li><a href="https://github.com/mearjuntripathi/Data_Structure_Algorithm/tree/main/Sorting#bubble-sort">Bubble
                sort</a></li>
        <li><a href="https://github.com/mearjuntripathi/Data_Structure_Algorithm/tree/main/Sorting#selection-sort">Selection
                sort</a></li>
        <li><a href="https://github.com/mearjuntripathi/Data_Structure_Algorithm/tree/main/Sorting#quick-sort">Quick
                sort</a></li>
        <li><a href="https://github.com/mearjuntripathi/Data_Structure_Algorithm/tree/main/Sorting#merge-sort">Merge
                sort</a></li>
        <li><a href="https://github.com/mearjuntripathi/Data_Structure_Algorithm/tree/main/Sorting#counting-sort">Count
                Sort</a></li>
    </ul>
    <h2 tabindex="-1" id="user-content-complexity-of-sorting-algorithm" dir="auto"><a class="heading-link"
            href="https://github.com/mearjuntripathi/Data_Structure_Algorithm/tree/main/Sorting#complexity-of-sorting-algorithm">Complexity
            of Sorting Algorithm<svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16"
                aria-hidden="true"></svg></a></h2>
    <p dir="auto">The
        complexity of sorting algorithm measures the running time of n items to
        be sorted. The operations in the sorting algorithm, where A1, A2 .....
        An contains the items to be sorted and B is an auxiliary location, can
        be generalized as:</p>
    <pre><ol type="a" dir="auto">
    <li>Comparisons- which tests whether Ai &lt; Aj or test whether Ai &lt; B </li>
    <li>Interchange- which switches the contents of Ai and Aj or of Ai and B</li>
    <li>Assignments- which set B = A and then set Aj = B or Aj = Ai</li>
</ol>
</pre>
    <p dir="auto">Normally, the complexity functions measure only the number
        of comparisons, since the number of other operations is at most a
        constant factor of the number of comparisons.</p>
    <hr>
    <h2 tabindex="-1" id="user-content-bubble-sort" dir="auto"><a class="heading-link"
            href="https://github.com/mearjuntripathi/Data_Structure_Algorithm/tree/main/Sorting#bubble-sort">Bubble
            Sort<svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16"
                aria-hidden="true"></svg></a></h2>
    <p dir="auto">In
        bubble sort, each element is compared with its adjacent element. If the
        first element is larger than the second one, then the positions of the
        elements are interchanged, otherwise it is not changed. Then next
        element is compared with its adjacent element and the same process is
        repeated for all the elements in the array until we get a sorted array.</p>
    <br>
    <p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow"
            href="https://camo.githubusercontent.com/b19b6e9d7ec1560a290916632bca749058a73be7e7eb236a4ede1b94e63cbdba/68747470733a2f2f7777772e77337265736f757263652e636f6d2f7733725f696d616765732f627562626c652d73686f72742e706e67"><img
                src="https://camo.githubusercontent.com/b19b6e9d7ec1560a290916632bca749058a73be7e7eb236a4ede1b94e63cbdba/68747470733a2f2f7777772e77337265736f757263652e636f6d2f7733725f696d616765732f627562626c652d73686f72742e706e67"
                alt="Bubble Sort" data-canonical-src="https://www.w3resource.com/w3r_images/bubble-short.png"
                style="max-width: 100%;"></a></p>
    <pre> Algorithm  

STEP 1: Start with the first element.

STEP 2: Compare the current element with the next element.

STEP 3: If the current element is greater than the next element, then swap both the elements. If not, move to the next element.

STEP 4: Repeat steps 1 – 3 until we get the sorted list.


Time Complexity  : O(n^2)
Space Complexity : O(1)

</pre>
    <h2 tabindex="-1" id="user-content-insertion-sort" dir="auto"><a class="heading-link"
            href="https://github.com/mearjuntripathi/Data_Structure_Algorithm/tree/main/Sorting#insertion-sort">Insertion
            Sort<svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16"
                aria-hidden="true"></svg></a></h2>
    <p dir="auto">Insertion
        sort algorithm sorts a set of values by inserting values into an
        existing sorted file. Compare the second element with first, if the
        first element is greater than second, place it before the first one.
        Otherwise place is just after the first one. Compare the third value
        with second. If the third value is greater than the second value then
        place it just after the second. Otherwise place the second value to the
        third place. And compare third value with the first value. If the third
        value is greater than the first value place the third value to second
        place, otherwise place the first value to second place. And place the
        third value to first place and so on.</p>
    <br>
    <p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow"
            href="https://camo.githubusercontent.com/cc512547fb90566ddb6964b9f84897a32985c97c34259cdc50a83382bc2529c2/68747470733a2f2f7777772e6372696f2e646f2f626c6f672f636f6e74656e742f696d616765732f323032322f30322f496e73657274696f6e2d736f72742d6578616d706c652e706e67"><img
                src="https://camo.githubusercontent.com/cc512547fb90566ddb6964b9f84897a32985c97c34259cdc50a83382bc2529c2/68747470733a2f2f7777772e6372696f2e646f2f626c6f672f636f6e74656e742f696d616765732f323032322f30322f496e73657274696f6e2d736f72742d6578616d706c652e706e67"
                alt="Insertion sort"
                data-canonical-src="https://www.crio.do/blog/content/images/2022/02/Insertion-sort-example.png"
                style="max-width: 100%;"></a></p>
    <pre> Algorithm 

Step 1 − If the element is the first one, it is already sorted.

Step 2 – Move to next element

Step 3 − Compare the current element with all elements in the sorted array

Step 4 – If the element in the sorted array is smaller than the current element, iterate to the next element. Otherwise, shift all the greater element in the array by one position towards the right

Step 5 − Insert the value at the correct position

Step 6 − Repeat until the complete list is sorted


Time Complexity : O(n^2)
Space Complexity : O(1)
</pre>
    <h2 tabindex="-1" id="user-content-selection-sort" dir="auto"><a class="heading-link"
            href="https://github.com/mearjuntripathi/Data_Structure_Algorithm/tree/main/Sorting#selection-sort">Selection
            Sort<svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16"
                aria-hidden="true"></svg></a></h2>
    <p dir="auto">The
        algorithm repeatedly selects the smallest (or largest) element from the
        unsorted portion of the list and swaps it with the first element of the
        unsorted portion.<br>
        This process is repeated for the remaining unsorted portion of the list until the entire list is sorted.</p>
    <br>
    <p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow"
            href="https://camo.githubusercontent.com/844b24aad0b5e455f13a5d424e2ac404b41676c0ca56a455209f169b2f8cc0c6/68747470733a2f2f7777772e77337265736f757263652e636f6d2f7733725f696d616765732f73656c656374696f6e2d73686f72742e706e67"><img
                src="https://camo.githubusercontent.com/844b24aad0b5e455f13a5d424e2ac404b41676c0ca56a455209f169b2f8cc0c6/68747470733a2f2f7777772e77337265736f757263652e636f6d2f7733725f696d616765732f73656c656374696f6e2d73686f72742e706e67"
                alt="Selection Sort" data-canonical-src="https://www.w3resource.com/w3r_images/selection-short.png"
                style="max-width: 100%;"></a></p>
    <pre>Algorithm
    
STEP 1 − Set MIN to location 0

STEP 2 − Search the minimum element in the list

STEP 3 − Swap with value at location MIN

STEP 4 − Increment MIN to point to next element

STEP 5 − Repeat until list is sorted

Time Complexity : O(n^2)
Space Complexity : O(1)
</pre>
    <h2 tabindex="-1" id="user-content-merge-sort" dir="auto"><a class="heading-link"
            href="https://github.com/mearjuntripathi/Data_Structure_Algorithm/tree/main/Sorting#merge-sort">Merge
            Sort<svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16"
                aria-hidden="true"></svg></a></h2>
    <p dir="auto">Merging
        is the process of combining two or more sorted array into a third
        sorted array. Divide the array into approximately n/2 sub-arrays of size
        two and set the element in each sub array. Merging each sub-array with
        the adjacent sub-array will get another sorted sub-array of size four.
        Repeat this process until there is only one array remaining of size n.</p>
    <br>
    <p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow"
            href="https://camo.githubusercontent.com/a7907cfe61489a7d91daec9393631ea925e6776a8eee3b6e8143d135730dfd34/68747470733a2f2f7777772e70726f6772616d697a2e636f6d2f73697465732f7475746f7269616c3270726f6772616d2f66696c65732f6d657267652d736f72742d6578616d706c655f302e706e67"><img
                src="https://camo.githubusercontent.com/a7907cfe61489a7d91daec9393631ea925e6776a8eee3b6e8143d135730dfd34/68747470733a2f2f7777772e70726f6772616d697a2e636f6d2f73697465732f7475746f7269616c3270726f6772616d2f66696c65732f6d657267652d736f72742d6578616d706c655f302e706e67"
                alt="merge sort"
                data-canonical-src="https://www.programiz.com/sites/tutorial2program/files/merge-sort-example_0.png"
                style="max-width: 100%;"></a></p>
    <pre>        Algotithm 
STEP 1 − if it is only one element in the list it is already sorted, return.

STEP 2 − divide the list recursively into two halves until it can no more be divided.

STEP 3 − merge the smaller lists into new list in sorted order.

Time Complexity : O(nlog(n))
Space Complexity : O(n)
</pre>
    <h2 tabindex="-1" id="user-content-quick-sort" dir="auto"><a class="heading-link"
            href="https://github.com/mearjuntripathi/Data_Structure_Algorithm/tree/main/Sorting#quick-sort">Quick
            Sort<svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16"
                aria-hidden="true"></svg></a></h2>
    <p dir="auto">It is one of the widely used sorting techniques and it is also called the partition-exchange sort.
        Quick sort is an efficient algorithm and it passes a very good time complexity in average case.<br>
        <br>
    </p>
    <p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow"
            href="https://camo.githubusercontent.com/ab1a5e795dfee78468e217505d4a042ecfc29e873635e2b963f042cfa34f4fe3/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313038302f312a2d4577337a372d627530676a4e584b4c36706c4c7a412e6a706567"><img
                src="https://camo.githubusercontent.com/ab1a5e795dfee78468e217505d4a042ecfc29e873635e2b963f042cfa34f4fe3/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313038302f312a2d4577337a372d627530676a4e584b4c36706c4c7a412e6a706567"
                alt="quick sort"
                data-canonical-src="https://cdn-images-1.medium.com/max/1080/1*-Ew3z7-bu0gjNXKL6plLzA.jpeg"
                style="max-width: 100%;"></a></p>
    <pre>Algorithm

Step 1: First check low is less then high

Step 2: Then make a pivot to lower element

Step 3: divide a array in two part 

    Step a: left side has a lower element as pivot 

    Step b: right side has a greator element as pivot

Step 4: And repeat step 1-3 for two subarray 

    Step a: one for greator element as pivot 

    Step b: one for lower lower element as pivot

Time Complexity : [ wrost case O(n^2) || best case : O(n) || average case : O(n log n)  ]
Space Complexity : O(log n)
</pre>
    <h2 tabindex="-1" id="user-content-counting-sort" dir="auto"><a class="heading-link"
            href="https://github.com/mearjuntripathi/Data_Structure_Algorithm/tree/main/Sorting#counting-sort">Counting
            Sort<svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16"
                aria-hidden="true"></svg></a></h2>
    <p dir="auto">Counting
        sort is a sorting technique based on keys between a specific range. It
        works by counting the number of objects having distinct key values (a
        kind of hashing). Then do some arithmetic operations to calculate the
        position of each object in the output sequence.</p>
    <p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow"
            href="https://camo.githubusercontent.com/3f5bfe33f262fdcbb53e140f578a448c0fd1d2c45a7438783750f4b3b81edd05/68747470733a2f2f70726570696e7374612e636f6d2f77702d636f6e74656e742f75706c6f6164732f323032302f30362f436f756e74696e672d536f72742d312e77656270"><img
                src="https://camo.githubusercontent.com/3f5bfe33f262fdcbb53e140f578a448c0fd1d2c45a7438783750f4b3b81edd05/68747470733a2f2f70726570696e7374612e636f6d2f77702d636f6e74656e742f75706c6f6164732f323032302f30362f436f756e74696e672d536f72742d312e77656270"
                alt="counting sort"
                data-canonical-src="https://prepinsta.com/wp-content/uploads/2020/06/Counting-Sort-1.webp"
                style="max-width: 100%;"></a></p>
    <h3 tabindex="-1" id="user-content-algorithm" dir="auto"><a class="heading-link"
            href="https://github.com/mearjuntripathi/Data_Structure_Algorithm/tree/main/Sorting#algorithm">Algorithm<svg
                class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"></svg></a>
    </h3>
    <pre class="notranslate"><code>Step 1 − I get a max element in array.

Step 2 – Create a new array of length max with element 0.

Step 3 − Increase a new array element as frequency of element in array.

Step 4 – After inserting we get a frequency of each element in array.

Step 5 − Reinsert the value in old array as their frequency.

Time Complexity: O(N + K) 
    
Auxiliary Space: O(N + K)

    where, N is the number of elements in the input array and K is the range of input.
<br><br><br>-------<br></code></pre>
</div>